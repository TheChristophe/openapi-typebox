import type Operation from '../../openapi/Operation.js';
import type Parameter from '../../openapi/Parameter.js';
import type Reference from '../../openapi/Reference.js';
import writeSourceFile from '../../writeSourceFile.js';
import type RequestBody from '../../openapi/RequestBody.js';

import routeToOperationName from './helpers/routeToOperationName.js';
import buildParameterTypes from './buildParameterTypes.js';
import refUnsupported from './helpers/refUnsupported.js';
import sanitizeVariableName from './helpers/sanitizeVariableName.js';
import buildUrl from './buildUrl.js';
import destructureParameters from './destructureParameters.js';
import buildResponseTypes from './buildResponseTypes.js';
import typeboxImportStatements from '../../schema2typebox/typeboxImportStatements.js';
import template from '../../templater.js';
import buildResponseReturn from './buildResponseReturn.js';
import configuration from '../../configuration.js';
import commentSanitize from './helpers/commentSanitize.js';

export class InvalidParamError extends Error {}

function forbidReferencesInParameters(
  parameters: (Parameter | Reference)[],
): asserts parameters is Parameter[] {
  parameters.forEach(refUnsupported);
}
function forbidReferencesInRequestBody(
  requestBody?: RequestBody | Reference,
): asserts requestBody is RequestBody | undefined {
  refUnsupported(requestBody);
}

const buildJsDoc = (operation: Operation) =>
  template.lines(
    '/**',
    operation.summary != null &&
      operation.summary.length > 0 &&
      template.lines(` * ${operation.summary}`, ' * '),
    operation.description != null &&
      operation.description.length > 0 &&
      template.lines(commentSanitize(operation.description, { firstLine: true }), ' * '),
    operation.externalDocs != null &&
      template.lines(
        ` * [${operation.externalDocs.description ?? 'External docs'}](${operation.externalDocs.url})`,
        ' * ',
      ),
    ' * autogenerated',
    ' * ',
    /*
    operation.parameters != null &&
      operation.parameters.length > 0 &&
      template.lines(
        operation.parameters.map((parameter) => {
          refUnsupported(parameter);
          return template.concat(
            ' * @param ',
            !parameter.required && '[',
            parameter.name,
            !parameter.required && ']',
            ' - ',
            parameter.deprecated && 'deprecated',
            parameter.deprecated && parameter.description && ': ',
            parameter.description && commentSanitize(parameter.description, { indent: 4 }),
          );
        }),
        ' * ',
      ),

     */
    operation.deprecated != null && ' * @deprecated',
    ' * @async',
    ' **/',
  );

const operationToFunction = (
  route: string,
  method: string,
  operation: Operation,
  outDir: string,
): {
  operationName: string;
  hasParams: boolean;
  importPath: string;
} => {
  const operationName = operation.operationId ?? routeToOperationName(route, method);

  const lines: string[] = [];
  const imports: string[] = [];

  const parameters = operation.parameters ?? [];
  const requestBody = operation.requestBody;
  forbidReferencesInParameters(parameters);
  forbidReferencesInRequestBody(requestBody);

  if (parameters.length > 0) {
    for (const param of parameters) {
      refUnsupported(param);
      if (!['path', 'query'].includes(param.in)) {
        console.error(`Unsupported parameter location ${param.in}`);
        //throw new NotImplementedError(`Unsupported parameter location ${param.in}`);
      }
    }
  }
  if (requestBody) {
    refUnsupported(requestBody);
  }

  lines.push(
    template.lines(
      "import { type ConfigOverrides } from '../clientConfig.js';",
      //"import { type ResponseBrand } from '../typeBranding.js';",
      "import { type ApiFunction } from '../apiFunction.js';",
      "import { HTTPInformational, HTTPSuccess, HTTPRedirection, HTTPClientError, HTTPServerError } from '../HTTPStatusCode.js';",
      configuration.throwOnError && "import ApiError from '../ApiError.js';",
      '',
    ),
  );

  const parameterTypeName = 'Params';
  const takesParameters = requestBody != null || parameters.length > 0;

  if (takesParameters) {
    const parameterSection = buildParameterTypes(parameterTypeName, parameters, requestBody);
    lines.push(parameterSection.code, '');
    if (parameterSection.extraImports) {
      imports.push(...parameterSection.extraImports, '');
    }
  }

  let successType: string = '';
  let errorType: string = '';

  if (operation.responses && Object.keys(operation.responses).length > 0) {
    const { successResponse, errorResponse, ...responseSection } = buildResponseTypes(
      operationName,
      operation.responses,
    );
    lines.push(responseSection.code, '');
    if (responseSection.extraImports) {
      imports.push(...responseSection.extraImports, '');
    }
    successType = successResponse;
    errorType = errorResponse;
  }

  const queryParams = parameters.filter((param) => param.in === 'query');

  lines.push(
    template.lines(
      buildJsDoc(operation),
      template.concat(
        `const ${operationName}: ApiFunction<`,
        takesParameters ? parameterTypeName : 'undefined',
        takesParameters
          ? ', AllResponses> = async (parameters) => {'
          : ', AllResponses> = async (parameters = {}) => {',
      ),

      template.lines(
        destructureParameters(parameters, requestBody),

        buildUrl(route, parameters),

        'const localFetch = config?.fetch ?? fetch;',
        'const headers = new Headers(config?.defaultParams?.headers);',
        '',
        'if (config?.auth?.bearer != null) {',
        // eslint-disable-next-line no-template-curly-in-string
        "  headers.set('authorization', `Bearer ${config.auth.bearer}`);",
        '}',
        '',

        'const response = await localFetch(',

        template.concat(
          // eslint-disable-next-line no-template-curly-in-string
          '`${url}',

          queryParams.length > 0 && [
            '?${new URLSearchParams({',

            queryParams.map(
              (param) =>
                `...(${sanitizeVariableName(param.name)} != null && {["${param.name}"]: ${sanitizeVariableName(param.name)}.toString()}),`,
            ),
            '}).toString()}',
          ],

          '`,',
        ),

        '{',
        '...config?.defaultParams,',
        `method: '${method.toUpperCase()}',`,
        'headers,',

        // TODO: non-json
        // TODO: how to handle multiple different request types?
        requestBody && 'body: JSON.stringify(body),',

        // TODO: headers

        '});',
        '',

        operation.responses == null &&
          template.lines('return ({', 'status: response.status,', `} as ${errorType});`),

        operation.responses != null && buildResponseReturn(operationName, operation.responses),
      ),
      '};',
      ' ',
      `export default ${operationName};`,
    ),
  );

  writeSourceFile(
    `${outDir}/functions/${operationName}.ts`,
    template.lines(typeboxImportStatements, '', imports, '', lines),
  );

  return {
    operationName,
    hasParams: takesParameters,
    importPath: `./functions/${operationName}.js`,
  };
};

export default operationToFunction;
